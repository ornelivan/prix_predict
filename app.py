# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UYo0NKwy7zwwCPfEu3wsHgcLsAvyZpPg
"""

import joblib
import numpy as np
import pandas as pd
import plotly.graph_objects as go
import streamlit as st
from dataclasses import dataclass
from typing import Optional, Dict, List, Tuple

APP_TITLE = "PREDICTION PRIX"
DEFAULT_MODEL_PATH = "best_model_BXY_LightGBM.pkl"

def load_css(path: str = "style.css") -> None:
    try:
        with open(path, "r", encoding="utf-8") as f:
            st.markdown(f"<style>{f.read()}</style>", unsafe_allow_html=True)
    except FileNotFoundError:
        pass

def parse_datetime_col(df: pd.DataFrame, col: str) -> pd.DataFrame:
    df = df.copy()
    df[col] = pd.to_datetime(df[col], errors="coerce", utc=True)
    df = df.dropna(subset=[col]).sort_values(col).set_index(col)
    return df

def ohlc_from_close(df: pd.DataFrame, close_col: str, freq: str) -> pd.DataFrame:
    o = df[close_col].resample(freq).first()
    h = df[close_col].resample(freq).max()
    l = df[close_col].resample(freq).min()
    c = df[close_col].resample(freq).last()
    return pd.DataFrame({"open": o, "high": h, "low": l, "close": c}).dropna()

def compute_rsi(close: pd.Series, period: int = 14) -> pd.Series:
    delta = close.diff()
    gain = delta.clip(lower=0)
    loss = -delta.clip(upper=0)
    avg_gain = gain.ewm(alpha=1/period, adjust=False).mean()
    avg_loss = loss.ewm(alpha=1/period, adjust=False).mean()
    rs = avg_gain / (avg_loss.replace(0, np.nan))
    rsi = 100 - (100 / (1 + rs))
    return rsi.fillna(50)

def compute_atr(ohlc: pd.DataFrame, period: int = 14) -> pd.Series:
    high, low, close = ohlc["high"], ohlc["low"], ohlc["close"]
    prev_close = close.shift(1)
    tr = pd.concat([(high-low), (high-prev_close).abs(), (low-prev_close).abs()], axis=1).max(axis=1)
    return tr.ewm(alpha=1/period, adjust=False).mean()

def add_ema(ohlc: pd.DataFrame, spans: Tuple[int,int]=(20,50)) -> pd.DataFrame:
    out = ohlc.copy()
    for s in spans:
        out[f"ema{s}"] = out["close"].ewm(span=s, adjust=False).mean()
    return out

def plot_candles(ohlc: pd.DataFrame, title: str, ema_spans: Tuple[int,int]=(20,50)) -> go.Figure:
    o = add_ema(ohlc, ema_spans)
    fig = go.Figure()
    fig.add_trace(go.Candlestick(x=o.index, open=o["open"], high=o["high"], low=o["low"], close=o["close"], name="OHLC"))
    for s in ema_spans:
        fig.add_trace(go.Scatter(x=o.index, y=o[f"ema{s}"], mode="lines", name=f"EMA{s}"))
    fig.update_layout(title=title, template="plotly_dark", height=520,
                      margin=dict(l=20,r=20,t=60,b=30), xaxis_rangeslider_visible=False)
    return fig

def get_model_feature_names(model) -> List[str]:
    if hasattr(model, "feature_name_"):
        return list(model.feature_name_)
    if hasattr(model, "feature_name"):
        try:
            return list(model.feature_name())
        except Exception:
            return []
    return []

def impact_to_level(impact: str) -> int:
    m = {"Low": 1, "Medium": 2, "High": 3}
    return m.get(impact, 0)

@dataclass
class EconInput:
    has_event: int
    impact_level: int
    surprise: float
    delta_prev: float
    event_type: str

# Les types que tu as listés (PIB/GDP/CPI/Unemployment/NFP/Employment Change/Manufacturing PMI/Trade Balance)
ECON_EVENT_TYPES = [
    "gdp","cpi","unemployment","nfp","employment_change",
    "manufacturing_pmi","trade_balance","speech","other"
]

def map_event_name(name: str) -> str:
    s = (name or "").lower()
    if "gdp" in s or "pib" in s: return "gdp"
    if "cpi" in s or "infl" in s: return "cpi"
    if "unemployment" in s: return "unemployment"
    if "nfp" in s or "non-farm" in s: return "nfp"
    if "employment change" in s: return "employment_change"
    if "manufacturing pmi" in s or ("pmi" in s and "services" not in s): return "manufacturing_pmi"
    if "trade balance" in s: return "trade_balance"
    if "speaks" in s or "speech" in s: return "speech"
    return "other"

def build_feature_vector(model_features: List[str], close: pd.Series, ref_time: pd.Timestamp,
                         n_lags: int, econ: Optional[EconInput]) -> pd.DataFrame:
    close = close.sort_index()
    if ref_time not in close.index:
        pos = close.index.get_indexer([ref_time], method="pad")[0]
        ref_time = close.index[pos]
    idx = close.index.get_loc(ref_time)
    if idx < n_lags:
        raise ValueError("Pas assez d'historique pour construire les lags au timestamp choisi.")

    row: Dict[str, float] = {f: 0.0 for f in model_features}

    # lags de prix
    for k in range(1, n_lags+1):
        lk = f"lag_{k}"
        if lk in row:
            row[lk] = float(close.iloc[idx-k])

    # news
    if econ is not None:
        for k in ["has_event","impact_level","surprise","delta_prev"]:
            if k in row:
                row[k] = float(getattr(econ, k))
        key = f"event_{(econ.event_type or 'other').lower().strip()}"
        if key in row:
            row[key] = 1.0

    return pd.DataFrame([row], columns=model_features)

# ---------------- UI ----------------
st.set_page_config(page_title=APP_TITLE, layout="wide")
load_css()
st.title(APP_TITLE)
st.caption("Analyse prix + indicateurs techniques + prédiction LightGBM avec variables de news (GDP/CPI/NFP/...).")

with st.sidebar:
    st.header("Données")
    model_path = st.text_input("Chemin modèle (.pkl)", value=DEFAULT_MODEL_PATH)
    price_file = st.file_uploader("CSV prix (obligatoire)", type=["csv"])
    events_file = st.file_uploader("CSV news (optionnel)", type=["csv"])
    st.divider()
    st.header("Colonnes")
    dt_col = st.text_input("datetime", value="datetime")
    close_col = st.text_input("close", value="close")
    st.divider()
    st.header("Paramètres")
    freq = st.selectbox("Resampling", ["1H","4H","1D"], index=0)
    n_lags = st.number_input("Nombre de lags", min_value=1, max_value=100, value=10, step=1)
    use_events_csv = st.checkbox("Utiliser news CSV pour la prédiction", value=bool(events_file))
    manual_econ = st.checkbox("Saisie manuelle des news", value=not bool(events_file))

@st.cache_data(show_spinner=False)
def read_csv(uploaded) -> pd.DataFrame:
    return pd.read_csv(uploaded)

@st.cache_resource(show_spinner=False)
def load_model(path: str):
    return joblib.load(path)

if price_file is None:
    st.info("Upload un fichier prix pour démarrer.")
    st.stop()

dfp_raw = read_csv(price_file)
if dt_col not in dfp_raw.columns or close_col not in dfp_raw.columns:
    st.error(f"Colonnes requises introuvables. Colonnes dispo: {list(dfp_raw.columns)}")
    st.stop()

dfp = parse_datetime_col(dfp_raw, dt_col).rename(columns={close_col:"close"})[["close"]].dropna()
ohlc = ohlc_from_close(dfp, "close", freq)

try:
    model = load_model(model_path)
except Exception as e:
    st.error(f"Erreur chargement modèle: {e}")
    st.stop()

model_features = get_model_feature_names(model)
if not model_features:
    model_features = [f"lag_{i}" for i in range(1, int(n_lags)+1)] + \
                     ["has_event","impact_level","surprise","delta_prev"] + \
                     [f"event_{t}" for t in ECON_EVENT_TYPES]
    st.warning("Noms de features du modèle non détectés → fallback features standard.")

tab1, tab2, tab3 = st.tabs([" Prix", " Indicateurs", " Prédiction"])

with tab1:
    n_show = st.slider("Derniers points OHLC à afficher", 100, min(3000, len(ohlc)), 800, 100)
    view = ohlc.tail(n_show)
    st.plotly_chart(plot_candles(view, f"Chandeliers ({freq}) + EMA20/EMA50"), use_container_width=True)

with tab2:
    view = ohlc.tail(1200).copy()
    view["rsi14"] = compute_rsi(view["close"], 14)
    view["atr14"] = compute_atr(view, 14)
    view = add_ema(view, (20,50))

    c1, c2 = st.columns(2)
    with c1:
        fig = go.Figure([go.Scatter(x=view.index, y=view["rsi14"], mode="lines", name="RSI14")])
        fig.add_hline(y=70, line_dash="dash"); fig.add_hline(y=30, line_dash="dash")
        fig.update_layout(title="RSI (14)", template="plotly_dark", height=350,
                          margin=dict(l=20,r=20,t=60,b=20))
        st.plotly_chart(fig, use_container_width=True)
    with c2:
        fig = go.Figure([go.Scatter(x=view.index, y=view["atr14"], mode="lines", name="ATR14")])
        fig.update_layout(title="ATR (14)", template="plotly_dark", height=350,
                          margin=dict(l=20,r=20,t=60,b=20))
        st.plotly_chart(fig, use_container_width=True)

    st.download_button(
        "Télécharger indicateurs (CSV)",
        data=view.reset_index().rename(columns={"index":"datetime"}).to_csv(index=False).encode("utf-8"),
        file_name="bxy_indicators.csv",
        mime="text/csv"
    )

with tab3:
    ref_default = ohlc.index.max()
    ref_date = st.date_input("Date (UTC)", value=ref_default.date(),
                             min_value=ohlc.index.min().date(), max_value=ohlc.index.max().date())
    ref_hour = st.slider("Heure (UTC)", 0, 23, int(ref_default.hour))
    ref_ts = pd.Timestamp(ref_date).tz_localize("UTC") + pd.Timedelta(hours=int(ref_hour))

    econ = None

    # news depuis CSV (dernier event <= ref_ts)
    if events_file is not None and use_events_csv:
        dfe = read_csv(events_file).copy()
        if "datetime" in dfe.columns:
            dfe["datetime"] = pd.to_datetime(dfe["datetime"], errors="coerce", utc=True)
            dfe = dfe.dropna(subset=["datetime"]).sort_values("datetime")
            sub = dfe[dfe["datetime"] <= ref_ts]
            if len(sub) > 0:
                last = sub.iloc[-1]
                impact = str(last.get("impact", "Low")).split()[0]
                actual = pd.to_numeric(last.get("actual", 0.0), errors="coerce")
                forecast = pd.to_numeric(last.get("forecast", 0.0), errors="coerce")
                previous = pd.to_numeric(last.get("previous", 0.0), errors="coerce")
                actual = 0.0 if np.isnan(actual) else float(actual)
                forecast = 0.0 if np.isnan(forecast) else float(forecast)
                previous = 0.0 if np.isnan(previous) else float(previous)

                econ = EconInput(
                    has_event=1,
                    impact_level=impact_to_level(impact),
                    surprise=actual - forecast,
                    delta_prev=actual - previous,
                    event_type=map_event_name(str(last.get("event","other")))
                )
                st.success(f"News utilisée: {last.get('event','?')} @ {pd.to_datetime(last['datetime']).strftime('%Y-%m-%d %H:%M UTC')}")
            else:
                st.info("Aucune news avant ce timestamp → features news = 0.")
        else:
            st.warning("Le fichier news doit contenir une colonne 'datetime'.")

    # saisie manuelle
    if manual_econ:
        st.markdown("### Saisie manuelle (optionnel)")
        c1, c2, c3 = st.columns(3)
        with c1:
            has_event = st.selectbox("Événement présent ?", [0,1], index=1)
            impact = st.selectbox("Impact", ["Low","Medium","High"], index=2)
        with c2:
            actual = st.number_input("Actual", value=0.0)
            forecast = st.number_input("Forecast", value=0.0)
        with c3:
            previous = st.number_input("Previous", value=0.0)
            et = st.selectbox("Type d'événement", ECON_EVENT_TYPES, index=0)

        econ = EconInput(int(has_event), impact_to_level(impact), float(actual-forecast), float(actual-previous), et)

    # features & prediction
    try:
        X = build_feature_vector(model_features, ohlc["close"], ref_ts, int(n_lags), econ)
    except Exception as e:
        st.error(str(e)); st.stop()

    st.write("Features (1 ligne) :")
    st.dataframe(X, use_container_width=True)

    y_pred = float(model.predict(X)[0])
    y_now = float(ohlc["close"].iloc[ohlc.index.get_indexer([ref_ts], method="pad")[0]])
    st.metric("Close à t (référence)", f"{y_now:.5f}")
    st.metric("Prédiction", f"{y_pred:.5f}")

    # petit graphe de contexte
    w = ohlc.loc[:ref_ts].tail(200)
    step = (w.index[-1] - w.index[-2]) if len(w) > 1 else pd.Timedelta(hours=1)
    fig = go.Figure()
    fig.add_trace(go.Scatter(x=w.index, y=w["close"], mode="lines", name="Close"))
    fig.add_trace(go.Scatter(x=[ref_ts], y=[y_now], mode="markers", name="t"))
    fig.add_trace(go.Scatter(x=[ref_ts + step], y=[y_pred], mode="markers", name="Pred (t+1)"))
    fig.update_layout(title="Contexte de prédiction", template="plotly_dark", height=350,
                      margin=dict(l=20,r=20,t=60,b=20))
    st.plotly_chart(fig, use_container_width=True)

    out = pd.DataFrame([{
        "ref_time_utc": ref_ts.isoformat(),
        "close_t": y_now,
        "pred": y_pred,
        "has_event": getattr(econ,"has_event",0) if econ else 0,
        "impact_level": getattr(econ,"impact_level",0) if econ else 0,
        "surprise": getattr(econ,"surprise",0.0) if econ else 0.0,
        "delta_prev": getattr(econ,"delta_prev",0.0) if econ else 0.0,
        "event_type": getattr(econ,"event_type","none") if econ else "none",
    }])
    st.download_button("Télécharger la prédiction (CSV)",
                       data=out.to_csv(index=False).encode("utf-8"),
                       file_name="bxy_prediction.csv",
                       mime="text/csv")