# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HdQUcD39UdgfoGds9Az459aAWB3Me7AK
"""

import streamlit as st
import pandas as pd
import numpy as np
import joblib
import matplotlib.pyplot as plt

# ==============================
# 1) CONFIGURATION G√âN√âRALE
# ==============================

st.set_page_config(page_title="Pr√©diction BXY - LightGBM",
                   layout="centered")

st.title("üìà Pr√©diction du prix BXY avec LightGBM optimis√©")

st.markdown("""
Cette application utilise un **mod√®le LightGBM** entra√Æn√© sur :
- 10 lags de prix (`lag_1` √† `lag_10`)
- des variables √©conomiques (news GBP) :
  - `has_event`, `impact_level`, `surprise`, `delta_prev`
  - `event_pmi`, `event_speech`, `event_money`, `event_lending`
""")

# ==============================
# 2) CHARGEMENT DU MOD√àLE
# ==============================

MODEL_PATH = "best_model_BXY_LightGBM.pkl"

@st.cache_resource
def load_model(path):
    return joblib.load(path)

try:
    model = load_model(MODEL_PATH)
    st.success(f"‚úÖ Mod√®le LightGBM charg√© depuis `{MODEL_PATH}`")
except Exception as e:
    st.error(f"‚ùå Impossible de charger le mod√®le `{MODEL_PATH}`.\nErreur : {e}")
    st.stop()

# Colonnes utilis√©es pendant l'entra√Ænement
FEATURE_COLS = [
    "lag_1", "lag_2", "lag_3", "lag_4", "lag_5",
    "lag_6", "lag_7", "lag_8", "lag_9", "lag_10",
    "has_event", "impact_level", "surprise", "delta_prev",
    "event_pmi", "event_speech", "event_money", "event_lending"
]

# ==============================
# 3) UPLOAD DU FICHIER BXY_PRIX
# ==============================

st.header("üìÇ 1. Charger ton fichier BXY_PRIX")

uploaded_file = st.file_uploader(
    "Charge ton fichier `BXY_PRIX.csv` contenant au minimum `datetime` et `BXY close`",
    type=["csv"]
)

if uploaded_file is None:
    st.info("üí° En attente du fichier BXY_PRIX.csv...")
    st.stop()

# Lecture des donn√©es
try:
    df = pd.read_csv(uploaded_file)
except Exception as e:
    st.error(f"Erreur de lecture du CSV : {e}")
    st.stop()

# V√©rification des colonnes n√©cessaires
required_cols = ["datetime", "BXY close"]
if not all(col in df.columns for col in required_cols):
    st.error(f"‚ùå Le fichier doit contenir au minimum les colonnes : {required_cols}")
    st.stop()

# Pr√©paration des donn√©es de prix
df["datetime"] = pd.to_datetime(df["datetime"])
df = df.sort_values("datetime")
df = df.set_index("datetime")
df["close"] = df["BXY close"]

st.success(f"‚úÖ Donn√©es charg√©es : {df.shape[0]} lignes")

# Affichage graphique des derniers prix
st.subheader("üìâ Derniers prix BXY")

nb_points = st.slider("Nombre de points √† afficher", 50, 1000, 200)
last_df = df.tail(nb_points)

fig, ax = plt.subplots(figsize=(8, 3))
ax.plot(last_df.index, last_df["close"])
ax.set_title("Derniers prix BXY")
ax.set_xlabel("Date")
ax.set_ylabel("Prix")
st.pyplot(fig)

# ==============================
# 4) CONSTRUCTION DES 10 LAGS
# ==============================

st.header("‚öôÔ∏è 2. Construction des features")

if df.shape[0] < 15:
    st.error("‚ùå Pas assez de donn√©es pour construire 10 lags.")
    st.stop()

# On prend les 10 derniers prix pour les lags
# Attention √† l'ordre : lag_1 = dernier prix, lag_2 = avant-dernier, etc.
last_closes = df["close"].tail(10).values[::-1]  # du plus r√©cent au plus ancien

lags_dict = {f"lag_{i+1}": last_closes[i] for i in range(10)}

st.write("üî¢ **Lags utilis√©s (pour la prochaine pr√©diction)** :")
st.write(lags_dict)

# ==============================
# 5) SC√âNARIO √âCONOMIQUE (NEWS)
# ==============================

st.header("üì∞ 3. Sc√©nario √©conomique (news GBP)")

col1, col2 = st.columns(2)

with col1:
    has_event = st.checkbox("Il y a un √©v√©nement √©conomique sur la p√©riode ?", value=False)
    impact_level = st.selectbox(
        "Impact attendu",
        options=[0, 1, 2, 3],
        format_func=lambda x: {
            0: "0 - Aucun",
            1: "1 - Low Impact",
            2: "2 - Medium Impact",
            3: "3 - High Impact"
        }[x],
        index=0
    )
    event_pmi = st.checkbox("√âv√©nement PMI ?", value=False)
    event_speech = st.checkbox("Discours BoE (Speech) ?", value=False)

with col2:
    surprise = st.number_input(
        "Surprise √©conomique (actual - forecast)",
        value=0.0,
        step=0.1,
        help="Diff√©rence entre la valeur publi√©e et le consensus"
    )
    delta_prev = st.number_input(
        "Delta vs pr√©c√©dent (actual - previous)",
        value=0.0,
        step=0.1
    )
    event_money = st.checkbox("√âv√©nement li√© √† Money Supply ?", value=False)
    event_lending = st.checkbox("√âv√©nement li√© au Lending ?", value=False)

# Encodage final des features macro
has_event_val = 1 if has_event else 0
event_pmi_val = 1 if event_pmi else 0
event_speech_val = 1 if event_speech else 0
event_money_val = 1 if event_money else 0
event_lending_val = 1 if event_lending else 0

# ==============================
# 6) CONSTRUCTION DU VECTEUR DE FEATURES
# ==============================

st.header("üßÆ 4. Construction du vecteur de features")

# Ordre EXACT des features comme √† l'entra√Ænement
features = [
    lags_dict["lag_1"],
    lags_dict["lag_2"],
    lags_dict["lag_3"],
    lags_dict["lag_4"],
    lags_dict["lag_5"],
    lags_dict["lag_6"],
    lags_dict["lag_7"],
    lags_dict["lag_8"],
    lags_dict["lag_9"],
    lags_dict["lag_10"],
    has_event_val,
    impact_level,
    surprise,
    delta_prev,
    event_pmi_val,
    event_speech_val,
    event_money_val,
    event_lending_val
]

X_input = pd.DataFrame([features], columns=FEATURE_COLS)

st.write("üìÑ **Vecteur de features envoy√© au mod√®le :**")
st.dataframe(X_input)

# ==============================
# 7) PR√âDICTION
# ==============================

st.header("üéØ 5. Pr√©diction du prochain prix BXY")

if st.button("üîÆ Lancer la pr√©diction"):
    try:
        y_pred = model.predict(X_input)[0]
        st.success(f"‚úÖ Prix BXY pr√©dit : **{y_pred:.5f}**")

        # Affichage d'un mini graphique avec la derni√®re valeur r√©elle + pr√©diction
        last_real = df["close"].iloc[-1]
        st.write(f"Dernier prix r√©el : {last_real:.5f}")

        fig2, ax2 = plt.subplots(figsize=(6, 3))
        ax2.plot(df["close"].tail(50).index, df["close"].tail(50).values, label="Prix r√©el")
        ax2.scatter(df.index[-1], df["close"].iloc[-1], color="blue", label="Dernier r√©el")
        ax2.scatter(df.index[-1] + pd.Timedelta(hours=1), y_pred, color="red", label="Pr√©vision +1h")
        ax2.legend()
        ax2.set_title("Derniers prix + pr√©vision")
        st.pyplot(fig2)

    except Exception as e:
        st.error(f"Erreur lors de la pr√©diction : {e}")